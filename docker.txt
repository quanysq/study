4. 在Docker中安装 Redis，并 asp.net core 项目中使用
	1. CMD 下载 NodeJs 镜像
		```
		docker pull redis:latest
		
		说明：
		大概 2 分钟
		```
	2. 查看镜像是否下载成功
		```
		C:\Users\Jacky>docker images
		REPOSITORY                       TAG           IMAGE ID       CREATED        SIZE
		redis                            latest        3358aea34e8c   2 weeks ago    117MB
		node                             latest        c71adfc6ec58   2 weeks ago    995MB
		webapiwithdocker                 latest        e12d6bba36c7   7 weeks ago    212MB
		alpine/git                       latest        b80d2cac43e4   8 weeks ago    43.6MB
		mcr.microsoft.com/mssql/server   2019-latest   4885f6112d74   2 months ago   1.47GB
		```
	3. 在 D:\database 创建两个目录：
		```
		D:\database\redis\conf
		D:\database\redis\data
		```
	4. 创建 reids.conf 文件，存储在 D:\database\redis\conf 目录下
		```
		D:\database\redis\conf\reids.conf
		
		内容：
		#用守护线程的方式启动 后台运行
		daemonize no 

		#给redis设置密码
		requirepass 123456 

		#redis持久化　　默认是no
		appendonly yes

		#防止出现远程主机强迫关闭了一个现有的连接的错误 默认是300
		tcp-keepalive 300 
		```
	5. 运行 Redis 镜像，创建 redis 容器
		```
		C:\Users\Jacky>docker run --name redis -p 16379:6379 -v /D/database/redis/conf/redis.conf:/etc/redis/redis_6379.conf -v /D/database/redis/data:/data/ -d redis:latest redis-server /etc/redis/redis_6379.conf --appendonly yes
		e69db3ef2158e21ea204da03267d0dc612d3d7cb1f9b8aecee5e3cffc0d58808
		
		说明：
		–name=“容器新名字”：为容器指定一个名称
		-p: 指定端口映射，格式为：主机(宿主)端口:容器端口
		-d: 后台运行容器，并返回容器ID
		-v /D/database/redis/conf/redis.conf:/etc/redis/redis_6379.conf 把宿主机配置好的redis.conf放到容器内的这个位置中
		-v /D/docker/redis/data:/data/ 把redis持久化的数据在宿主机内显示，做数据备份
		```
	6. 进入容器并尝试配置和读取值
		```
		C:\Users\Jacky>docker exec -it redis redis-cli
		127.0.0.1:6379> set name long
		OK
		127.0.0.1:6379> get name
		"long"
		127.0.0.1:6379> set msg "hello world redis"
		OK
		127.0.0.1:6379> get name
		"long"
		127.0.0.1:6379>
		
		说明：
		redis-cli表示运行一个redis客户端 (-a 123456 指定密码)
		set name "{value}" 配置 key=name value={value} 
		get name 读取 key=name 的 value
		```
	7. asp.net core webapi 项目中使用:
		1. 在 SqlServer 中创建表 T_Configs
			> 表包含Id、Name、Value这3列，Id列定义为整数类型的标识列，Name列和Value列都定义为字符串类型，Name列为配置项的名字，Value列为配置项的值
		2. 将 Redis 连接配置写到 T_Configs 表
			```
			Name: Redis
			Value: {"ConnStr":"127.0.0.1:16379,allowadmin=true"}
			```
		3. Nuget 安装以下三个包：
			```
			StackExchange.Redis
			System.Data.SqlClient
			Zack.AnyDBConfigProvider
			```
		4. 在项目上右击，选择【管理用户机密】。secrets.json内容如下
			```
			{
			  "ConnectionStrings": { "configServer": "Server=(localdb)\\mssqllocaldb;Database=TestDB;Trusted_Connection=True;MultipleActiveResultSets=true" }
			}
			
			说明：
			secrets.json 存储在 C:\Users\Jacky\AppData\Roaming\Microsoft\UserSecrets\{sha256码，在csproj中可以看到}\secrets.json
			如果secrets.json已经创建，点击【管理用户机密】
			```
		5. 在 Program.cs 页中读取配置和注入 Redis 连接对象 IConnectionMultiplexer
			```
			using StackExchange.Redis;
			using System.Data.SqlClient;

			var builder = WebApplication.CreateBuilder(args);
			......
			builder.Host.ConfigureAppConfiguration((_, configBuilder) => {
				//读取用户机密文件中的sqlserver连接串
				string connStr = builder.Configuration.GetConnectionString("configServer");
				configBuilder.AddDbConfiguration(() => new SqlConnection(connStr));
			});
			//采用直接读取builder.Configuration的方式来读取配置
			builder.Services.AddSingleton<IConnectionMultiplexer>(sp => {
				string connStr = builder.Configuration.GetValue<string>("Redis:ConnStr");
				return ConnectionMultiplexer.Connect(connStr);
			}); 
			......
			var app = builder.Build();
			```
		6. 在控制器中的构造方法声明
			```
			using Microsoft.AspNetCore.Mvc;
			using Microsoft.Extensions.Options;
			using StackExchange.Redis;

			namespace 配置系统集成1.Controllers
			{
				[ApiController]
				[Route("[controller]/[action]")]
				public class HomeController : ControllerBase
				{
					private readonly IOptionsSnapshot<SmtpOptions> smtpOptions;
					private readonly IConnectionMultiplexer connMultiplexer;

					public HomeController(
						IOptionsSnapshot<SmtpOptions> smtpOptions,
						IConnectionMultiplexer connMultiplexer)
					{
						this.smtpOptions = smtpOptions;
						this.connMultiplexer = connMultiplexer;
					}

					[HttpGet]
					public async Task<string> Index()
					{
						var opt = smtpOptions.Value;
						var timeSpan = connMultiplexer.GetDatabase().Ping();
						
						//写入和读取 Key-value
						var database = connMultiplexer.GetDatabase(1);
						await database.StringSetAsync("name", "Jacky");
						string str = await database.StringGetAsync("name");

						return $"Smtp:{opt} timeSpan:{timeSpan} str:{str}";
					}
				}
			}
			```
			

C:\Users\Jacky>docker pull redis:latest
latest: Pulling from library/redis
a603fa5e3b41: Pull complete
77631c3ef092: Pull complete
ed3847cf62b8: Pull complete
261a8b530567: Pull complete
7d9005a8af6d: Pull complete
828da1afb5be: Pull complete
Digest: sha256:1e3207c292225b6dd21cb74d59255748a50e8f739dd983040df38fa913927cf1
Status: Downloaded newer image for redis:latest
docker.io/library/redis:latest

C:\Users\Jacky>docker images
REPOSITORY                       TAG           IMAGE ID       CREATED        SIZE
redis                            latest        3358aea34e8c   2 weeks ago    117MB
node                             latest        c71adfc6ec58   2 weeks ago    995MB
webapiwithdocker                 latest        e12d6bba36c7   7 weeks ago    212MB
alpine/git                       latest        b80d2cac43e4   8 weeks ago    43.6MB
mcr.microsoft.com/mssql/server   2019-latest   4885f6112d74   2 months ago   1.47GB

C:\Users\Jacky>docker run --name redis -p 16379:6379 -v /D/database/redis/conf/redis.conf:/etc/redis/redis_6379.conf -v /D/database/redis/data:/data/ -d redis:latest redis-server /etc/redis/redis_6379.conf --appendonly yes
e69db3ef2158e21ea204da03267d0dc612d3d7cb1f9b8aecee5e3cffc0d58808

C:\Users\Jacky>docker exec -it redis redis-cli
127.0.0.1:6379> set name long
OK
127.0.0.1:6379> get name
"long"
127.0.0.1:6379> set msg "hello world redis"
OK
127.0.0.1:6379> get name
"long"
127.0.0.1:6379>