using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Console024
{
  /// <summary>
  /// 观察者模式(Observer Pattern） 
  /// </summary>
  public class C16
  {
    public static void Execute()
    {
      Console.WriteLine("=======推模式=======");
      C16_1.Execute();
      Console.WriteLine("");
      Console.WriteLine("=======拉模式=======");
      C16_2.Execute();
      Console.WriteLine("");
      Console.WriteLine("=======NET方式：事件+委托=======");
      C16_3.Execute();
    }
  }

  /*
   * 适用性：
      1．当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。
      2．当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。
      3．当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。
   * 
   * 在Observer模式中同样区分推模式和拉模式，两者的区别：推模式是当有消息时，把消息信息以参数的形式传递（推）给所有观察者，而拉模式是
   * 当有消息时，通知消息的方法本身并不带任何的参数，是由观察者自己到主体对象那儿取回（拉）消息。
   * 
   * 推模式的好处：当有消息时，所有的观察者都会直接得到全部的消息，并进行相应的处理程序，与主体对象没什么关系，两者之间的关系是
   * 一种松散耦合。但是它也有缺陷，第一是所有的观察者得到的消息是一样的，也许有些信息对某个观察者来说根本就用不上，也就是观察者
   * 不能“按需所取”；第二，当通知消息的参数有变化时，所有的观察者对象都要变化。
   * 
   * 拉模式是由观察者自己主动去取消息，需要什么信息，就可以取什么，不会像推模式那样得到所有的消息参数。
   * 
   * Observer实现要点:
      1．使用面向对象的抽象，Observer模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达到松耦合。
      2．目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。观察者自己决定是否需要订阅通知。目标对象对此一无所知。
      3．在C#中的Event。委托充当了抽象的Observer接口，而提供事件的对象充当了目标对象，委托是比抽象Observer接口更为松耦合的设计。
   */
}
